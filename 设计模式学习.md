# 面向对象特性

## 封装：访问权限控制

暴露少许方法，屏蔽太多业务细节，减少用错的概率。提高易维护性

## 抽象：如何隐藏方法的具体实现

​	只需了解接口暴露了哪些方法，无需查看类的具体实现逻辑。

​	设计思路：只关注功能点，不关注实现，过滤许多非必要的信息。

​	基于接口的抽象，可以在不改变原有实现的情况下，轻松替换新的实现逻辑，提高可扩展性。

​	例如：定义方法名或类名的时候，不要暴露太多细节，以保证后续改变实现逻辑的时候，无需修改其定义。

## 继承：复用

组合关系可以替代继承，少用继承。

过度继承，代码可读性、可维护性变差。子、父类高度耦合，修改父类直接影响子类。

## 多态：子类可以替代父类

基于这个特性，修改一个功能实现的时候，可以实现一个新的子类的方式，在子类中重写原来的功能逻辑，用子类替换父类。在实际的代码运行过程中，调用子类新的功能逻辑，而不是在原有代码上做修改。遵从了对修改关闭，对扩展开放的设计原则。

继承、接口、duck-typing语法可以实现多态。

```java
// 接口实现的多态
public interface Iterator {
  boolean hasNext();
  String next();
  String remove();
}

public class Array implements Iterator {
  private String[] data;

  public boolean hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法...
}

public class LinkedList implements Iterator {
  private LinkedListNode head;

  public boolean hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法... 
}

public class Demo {
  private static void print(Iterator iterator) {
    while (iterator.hasNext()) {
      System.out.println(iterator.next());
    }
  }

  public static void main(String[] args) {
    Iterator arrayIterator = new Array();
    print(arrayIterator);

    Iterator linkedListIterator = new LinkedList();
    print(linkedListIterator);
  }
}
// 所谓多态，在此例中，一个print方法，就可以应对各种集合的打印，表现了多态的复用性。新增map只需要实现map的相应方法即可，无需修改array和list，则表现了多态的扩展性。
```

​	

# 面向对象

以方法或函数为组织代码的基本单元，以数据与方法分离为主要的特点。面对问题的时候一上来就思考如何将复杂的流程拆解成一个一个方法，然后按相应的流程去执行

# 面向过程

以类或对象为组织代码的基本单元，将封、抽象、继承、多态特性作为代码设计和实现的基石。以类为思考对象，先给业务建模，将需求翻译成类，思考如何给类之间建立交互关系。然后再像搭积木一样，将类组装成程序。

# 看似面向对象实际是面向过程的代码

## 滥用getter和setter

破坏了封装性

在实现类的时候，除非真的需要，否则，尽量不要给属性定义setter方法。除此之外，尽管getter方法相对setter方法更安全，但返回的如果是集合容器，也要防范内部数据被修改的危险

## 滥用全局变量和全局方法

常见的全局变量有单例类对象、静态成员变量、常量等，常见的全局方法有静态方法。单例类对象在全局代码中只有一份，相当于一个全局变量。静态成员变量归属于类被所有实例化对象共享，也相当于一定程度的全局变量。常量一般放到一个Constants类中。静态方法一般用来操作静态变量或者外部数据，比如各种Utils类，静态方法将方法与数据分离，破坏了封装性。

Constants类不是个好的设计思路，理由如下：

1. 多人协作频繁修改这个类，类会越来越大，查找比较费时，增加提交冲突概率
2. 增加代码编译时间。依赖Constants类的代码很多，每次修改就会导致依赖的类文件重新编译。
3. 影响代码复用性。复用某个类A，而A有依赖Constants，即便只是很小的一部分常量，仍然需要将整个Constants一并引入，即引入了很多无关的常量。

那么如何避免？

1. 定义多个功能明确的Constants类。如RedisConstants，MySQLConstants等等。这种也并不是放好
2. 哪个类用到了某个常量，将这个常量定义到类中，提高类设计的内聚性和代码复用性。

Utils类

相同功能逻辑的代码复用。在使用之前需要问一下自己，真的需要单独定义一个Utils类吗，是否可以把Utils类中的某些方法定义到其他类中？使用时最好也针对不同功能设计不同Utils类，如FileUtils、StringUtils等等。

## 定义数据和方法分离的类

Controller、Service、Repository。其中VO、BO、DO等等，都是只定义数据，不定义方法，这是典型的面向过程的变成风格。

# 接口和抽象类

## 接口

has-a关系，用于解决抽象的问题

## 抽象类

is-a关系，用于解决既有复用且子类有一定要实现多态关系的问题

## 区别

- 相同点：
  - 都不能被实例化。
  - 都可以包含抽象方法。
  - 都可以有默认实现的方法（Java 8 可以用 `default` 关键字在接口中定义默认方法）。
- 不同点：
  - 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。
  - 一个类只能继承一个类，但是可以实现多个接口。
  - 接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。

# 设计原则

- 基于接口（抽象）而非实现编程

  将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游无需改动，一次降低代码间的耦合性，提高代码的扩展性。

  因此，当业务场景中，某个中能只有一种实现方式，未来也不能被其他实现方式替换，就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类即可。反之则需要设计。

- 组合优于继承

  ```java
  public interface Flyable {
    void fly()；
  }
  public class FlyAbility implements Flyable {
    @Override
    public void fly() { //... }
  }
  //省略Tweetable/TweetAbility/EggLayable/EggLayAbility
  
  public class Ostrich implements Tweetable, EggLayable {//鸵鸟
    private TweetAbility tweetAbility = new TweetAbility(); //组合
    private EggLayAbility eggLayAbility = new EggLayAbility(); //组合
    //... 省略其他属性和方法...
    @Override
    public void tweet() {
      tweetAbility.tweet(); // 委托
    }
    @Override
    public void layEgg() {
      eggLayAbility.layEgg(); // 委托
    }
  }
  ```

  继承的主要作用：复用、多态、is-a关系。

  1. is-a关系可以使用组合+接口的has-a关系替代

  2. 多态可以利用接口实现

  3. 复用可以使用组合+委托实现

  使用上面3个方式替换继承，可以有效避免继承嵌套，导致代码难以阅读，维护，当父类修改时影响过大。

  如何判断该用组合还是继承？

  如果类之间的关系结构稳定，不会轻易改变，继承层次较浅（两层），使用继承没有问题。反之则使用组合	

































