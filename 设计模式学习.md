# 面向对象特性

## 封装：访问权限控制

暴露少许方法，屏蔽太多业务细节，减少用错的概率。提高易维护性

## 抽象：如何隐藏方法的具体实现

​	只需了解接口暴露了哪些方法，无需查看类的具体实现逻辑。

​	设计思路：只关注功能点，不关注实现，过滤许多非必要的信息。

​	基于接口的抽象，可以在不改变原有实现的情况下，轻松替换新的实现逻辑，提高可扩展性。

​	例如：定义方法名或类名的时候，不要暴露太多细节，以保证后续改变实现逻辑的时候，无需修改其定义。

## 继承：复用

组合关系可以替代继承，少用继承。

过度继承，代码可读性、可维护性变差。子、父类高度耦合，修改父类直接影响子类。

## 多态：子类可以替代父类

基于这个特性，修改一个功能实现的时候，可以实现一个新的子类的方式，在子类中重写原来的功能逻辑，用子类替换父类。在实际的代码运行过程中，调用子类新的功能逻辑，而不是在原有代码上做修改。遵从了对修改关闭，对扩展开放的设计原则。

继承、接口、duck-typing语法可以实现多态。

```java
// 接口实现的多态
public interface Iterator {
  boolean hasNext();
  String next();
  String remove();
}

public class Array implements Iterator {
  private String[] data;

  public boolean hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法...
}

public class LinkedList implements Iterator {
  private LinkedListNode head;

  public boolean hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法... 
}

public class Demo {
  private static void print(Iterator iterator) {
    while (iterator.hasNext()) {
      System.out.println(iterator.next());
    }
  }

  public static void main(String[] args) {
    Iterator arrayIterator = new Array();
    print(arrayIterator);

    Iterator linkedListIterator = new LinkedList();
    print(linkedListIterator);
  }
}
// 所谓多态，在此例中，一个print方法，就可以应对各种集合的打印，表现了多态的复用性。新增map只需要实现map的相应方法即可，无需修改array和list，则表现了多态的扩展性。
```

​	

# 面向对象

以方法或函数为组织代码的基本单元，以数据与方法分离为主要的特点。面对问题的时候一上来就思考如何将复杂的流程拆解成一个一个方法，然后按相应的流程去执行

# 面向过程

以类或对象为组织代码的基本单元，将封、抽象、继承、多态特性作为代码设计和实现的基石。以类为思考对象，先给业务建模，将需求翻译成类，思考如何给类之间建立交互关系。然后再像搭积木一样，将类组装成程序。

# 看似面向对象实际是面向过程的代码

## 滥用getter和setter

破坏了封装性

在实现类的时候，除非真的需要，否则，尽量不要给属性定义setter方法。除此之外，尽管getter方法相对setter方法更安全，但返回的如果是集合容器，也要防范内部数据被修改的危险

## 滥用全局变量和全局方法

常见的全局变量有单例类对象、静态成员变量、常量等，常见的全局方法有静态方法。单例类对象在全局代码中只有一份，相当于一个全局变量。静态成员变量归属于类被所有实例化对象共享，也相当于一定程度的全局变量。常量一般放到一个Constants类中。静态方法一般用来操作静态变量或者外部数据，比如各种Utils类，静态方法将方法与数据分离，破坏了封装性。

Constants类不是个好的设计思路，理由如下：

1. 多人协作频繁修改这个类，类会越来越大，查找比较费时，增加提交冲突概率
2. 增加代码编译时间。依赖Constants类的代码很多，每次修改就会导致依赖的类文件重新编译。
3. 影响代码复用性。复用某个类A，而A有依赖Constants，即便只是很小的一部分常量，仍然需要将整个Constants一并引入，即引入了很多无关的常量。

那么如何避免？

1. 定义多个功能明确的Constants类。如RedisConstants，MySQLConstants等等。这种也并不是放好
2. 哪个类用到了某个常量，将这个常量定义到类中，提高类设计的内聚性和代码复用性。

Utils类

相同功能逻辑的代码复用。在使用之前需要问一下自己，真的需要单独定义一个Utils类吗，是否可以把Utils类中的某些方法定义到其他类中？使用时最好也针对不同功能设计不同Utils类，如FileUtils、StringUtils等等。

## 定义数据和方法分离的类

Controller、Service、Repository。其中VO、BO、DO等等，都是只定义数据，不定义方法，这是典型的面向过程的变成风格。

# 接口和抽象类

## 接口

has-a关系，用于解决抽象的问题

## 抽象类

is-a关系，用于解决既有复用且子类有一定要实现多态关系的问题

## 区别

- 相同点：
  - 都不能被实例化。
  - 都可以包含抽象方法。
  - 都可以有默认实现的方法（Java 8 可以用 `default` 关键字在接口中定义默认方法）。
- 不同点：
  - 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。
  - 一个类只能继承一个类，但是可以实现多个接口。
  - 接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。

# 设计原则

## 基于接口（抽象）而非实现编程

将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游无需改动，一次降低代码间的耦合性，提高代码的扩展性。

因此，当业务场景中，某个中能只有一种实现方式，未来也不能被其他实现方式替换，就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类即可。反之则需要设计。

## 组合优于继承

```java
public interface Flyable {
  void fly()；
}
public class FlyAbility implements Flyable {
  @Override
  public void fly() { //... }
}
//省略Tweetable/TweetAbility/EggLayable/EggLayAbility

public class Ostrich implements Tweetable, EggLayable {//鸵鸟
  private TweetAbility tweetAbility = new TweetAbility(); //组合
  private EggLayAbility eggLayAbility = new EggLayAbility(); //组合
  //... 省略其他属性和方法...
  @Override
  public void tweet() {
    tweetAbility.tweet(); // 委托
  }
  @Override
  public void layEgg() {
    eggLayAbility.layEgg(); // 委托
  }
}
```

继承的主要作用：复用、多态、is-a关系。

1. is-a关系可以使用组合+接口的has-a关系替代

2. 多态可以利用接口实现

3. 复用可以使用组合+委托实现

使用上面3个方式替换继承，可以有效避免继承嵌套，导致代码难以阅读，维护，当父类修改时影响过大。

如何判断该用组合还是继承？

如果类之间的关系结构稳定，不会轻易改变，继承层次较浅（两层），使用继承没有问题。反之则使用组合

## 单一职责

因为从不同业务层面、不同应用场景去评价一个类的职责是否足够单一，并没有明确、可量化的标准。可以先写一个粗粒度的类，随着业务的发展，有必要的话可以将它拆分成更细粒度的类，即需要持续重构

有这么几条判断原则：可以参考

- 类中代码行数、函数、属性过多，影响可读性和可维护性，考虑拆分。比如200行，10个属性，10个函数
- 依赖其他类过多，或依赖类的其他类过多，不符合高内聚、低耦合的设计思想，考虑拆分
- 私有方法过多，考虑能否将私有方法独立到新的类中，设置为public，供更多的类使用，提高可复用性
- 比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用些笼统的Manager、Context之类的词语命名，说明类的职责定义不够清晰
- 类中大量的方法都是集中操作类中的某几个属性，将这些方法和属性拆分出来

类的职责也不是设计的越单一越好，太单一可能导致内聚性降低，可维护性差

## 开闭原则

对扩展开放，对修改关闭，如何理解？

为了尽量写出扩展性好的代码，要时刻具备扩展意识、抽象意识、封装意识。写代码的时候，多花时间思考一下，代码未来可能有哪些需求变更，如何设计代码结构，实现留好扩展点，一遍在未来需求变更的时候，不需要改动代码整体结构，做到最小代码改动的情况下，新的代码能够很灵活的插入到扩展点上，做到"对扩展开放、对修改关闭"。

在识别出代码可变部分和不可变部分之后，将可变部分封装起来，隔离变化，提供抽象画的不可变接口，给上层系统使用。但具体实现发生变化的时候，只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。

## 里氏替换原则

如何理解里氏替换原则LSP？

和多态类似，但是关注点不同。多态是面向对象编程的一大特性，一种语法，一种代码实现的思路，而里氏替换是一种设计原则，指导继承关系中子类如何设计，保证替换父类的时候不改变原有程序逻辑以及不破坏原有程序的正确性。

如子类继承父类，如果在重写父类方法的时候抛出异常，这样就不符合里氏替换原则。

其更加有指导意义的描述是：Design by Contract，按照协议来设计。子类在设计的时候，要遵守父类的行为约定（协议）。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。这些约定包括：输入、输出、异常，甚至包括注释说明。定义中子类与父类也可以替换成接口和实现类之间的关系。

哪些代码明显违背了LSP?

1. 子类违背父类声明要实现的功能。例如父类方法按大小排序，子类实现按日期排序，就不符合LSP。
2. 子类违背父类对输入、输出、异常的约定。例如父类在函数中约定出错时返回null，数据为空时返回empty，子类重载之后，运行出错返回异常，数据为空时为null，不符合LSP。还有抛出异常范围、输入类型范围等等，都可能不符合。
3. 子类违背父类注释中 所罗列的任何特殊说明。例如父类对方法注释最大数值不能大于100，而子类实现处理特殊情况使最大数值大于100，不符合LSP。

## 接口隔离原则

客户端（调用者、使用者）不应该被迫依赖它不需要的接口。缩写为ISP

其中，接口可以理解成三类东西：

- 一组API接口集合

  在设计微服务或类库接口的时候，如果接口只被部分调用者使用，那就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不被用到的接口

- 单个API接口或函数

  类似于单一职责原则。函数或方法的职责应该单一，结合具体的场景使用。但还是有区别，单一职责原则针对的是模块、类、接口的设计。而ISP一方面更侧重于接口的设计，另一个方面它的思考角度不同。提供了一种判断接口是否职责单一的标准：通过调用者和如何使用接口来间接的判断。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。

- OOP中的接口概念

```java
public interface Updater {
  void update();
}

public interface Viewer {
  String outputInPlainText();
  Map<String, String> output();
}

public class RedisConfig implemets Updater, Viewer {
  //...省略其他属性和方法...
  @Override
  public void update() { //... }
  @Override
  public String outputInPlainText() { //... }
  @Override
  public Map<String, String> output() { //...}
}

public class KafkaConfig implements Updater {
  //...省略其他属性和方法...
  @Override
  public void update() { //... }
}

public class MysqlConfig implements Viewer {
  //...省略其他属性和方法...
  @Override
  public String outputInPlainText() { //... }
  @Override
  public Map<String, String> output() { //...}
}

public class SimpleHttpServer {
  private String host;
  private int port;
  private Map<String, List<Viewer>> viewers = new HashMap<>();
  
  public SimpleHttpServer(String host, int port) {//...}
  
  public void addViewers(String urlDirectory, Viewer viewer) {
    if (!viewers.containsKey(urlDirectory)) {
      viewers.put(urlDirectory, new ArrayList<Viewer>());
    }
    this.viewers.get(urlDirectory).add(viewer);
  }
  
  public void run() { //... }
}

public class Application {
    ConfigSource configSource = new ZookeeperConfigSource();
    public static final RedisConfig redisConfig = new RedisConfig(configSource);
    public static final KafkaConfig kafkaConfig = new KakfaConfig(configSource);
    public static final MySqlConfig mysqlConfig = new MySqlConfig(configSource);
    
    public static void main(String[] args) {
        ScheduledUpdater redisConfigUpdater =
            new ScheduledUpdater(redisConfig, 300, 300);
        redisConfigUpdater.run();
        
        ScheduledUpdater kafkaConfigUpdater =
            new ScheduledUpdater(kafkaConfig, 60, 60);
        redisConfigUpdater.run();
        
        SimpleHttpServer simpleHttpServer = new SimpleHttpServer(“127.0.0.1”, 2389);
        simpleHttpServer.addViewer("/config", redisConfig);
        simpleHttpServer.addViewer("/config", mysqlConfig);
        simpleHttpServer.run();
    }
}
```

示例中，设计了两个功能非常单一的接口，updater和viewer。ScheduledUpdater 只依赖 Updater 这个跟热更新相关的接口，不需要被强迫去依赖不需要的 Viewer 接口，满足接口隔离原则。同理，SimpleHttpServer 只依赖跟查看信息相关的 Viewer 接口，不依赖不需要的 Updater 接口，也满足接口隔离原则。

## 依赖反转原则

- 控制翻转IOC
- 依赖注入DI
- 依赖注入框架DI Framework
- 依赖反转原则DIP







































# 领域驱动设计DDD

- 贫血模式：重service轻BO

- 充血模式：轻service重Domain

- 区别：

  - 平时的开发大部分是SQL驱动的开发模式。接到一个接口开发需求的时候，去看接口需要的数据对应到数据库中，需要哪些表，然后思考如何编写SQL语句来获取数据，之后定义DO、BO、VO，然后模板滴往对应的Repository、Service和Controller中添加代码。其结果就是，业务逻辑包含在大的SQL语句中，而Service层可以做的事情很少。SQL都是针对特定的业务功能编写的，复用性差。当开发另一个业务功能的时候，只能重写一个满足需求的SQL，导致各种长得差不多，区别很小的SQL语句满天飞。
  - 基于充血模式的DDD开发模式下，事先需要理清所有的一万五，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层。新功能需求的开发，都基于之前定义好的领域模型来完成。

- 适用范围：

  - 贫血适合简单的CRUD相关操作，没有复杂的业务逻辑

  - 充血适合复杂的业务逻辑，如各种李鑫计算模型、还款模型等复杂业务的金融系统

    





























