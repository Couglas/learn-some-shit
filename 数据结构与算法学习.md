- 2^x=n  -> n = log2n
- 数组
- 链表经典应用场景-LRU
- 栈
  - 算数：两个栈，一个操作数栈，一个操作符栈
  - 括号匹配
  - 浏览器：两个栈，一个前进，一个后退
- 队列
  - 顺序队列
  - 环形队列
  - 阻塞队列
  - 并发队列
- 递归
  - 三个条件是什么
  - 堆栈溢出怎么解决
  - 递归容易导致重复计算，可以采用哈希表存储已经计算的步骤，避免重复。

- 排序

  - O(n^2)

    - 冒泡排序：原地，稳定
    - 插入排序：原地，稳定。比冒泡更快，每次交换少了几个操作。
    - 选择排序：原地：不稳定

  - O(nlogn)

    - 归并排序：非原地，稳定。递归+分区（分区内排序，最后合并所有分区）
    - 快速排序：原地，不稳定。递归+分区（大的放右边，小的放左边）

  - O(n)

    - 桶排序：非原地，稳定

      将所有数据均匀分到桶中，依次遍历桶读取就是顺序的。难点在于很难均匀分，只适合外部排序。

    - 计数排序：非原地，稳定

      特殊的桶排序。

      如：排序序列A。将序列A中元素的数值范围作为桶的个数，每个桶中存放对应数值的元素个数，记作序列C1。然后将每个位置的数据改为起始位置到当前位置累加之和记作序列C2。从后到前遍历A，找每个元素在C2中对应的值，即为排好序的序列R的相应下标。遍历完一次之后，序列A就被排序成序列R。

    - 基数排序：非原地，稳定

      如排序10w个手机号，桶排序和计数排序都派不上用场，手机号的值太大。利用当a前几位已经大于b时，后续就不用再看。思路为：先排序最后一位，然后倒数第二位，直到第一位，经过11次排序就有序了。每次排序必须是稳定排序才行，因此可以选快排、桶、计数等排序。如果位数都不相同，或者有负数，有小数，可以采用补0，+正数，乘10^n来解决。	