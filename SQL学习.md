# 数据缓冲池

数据库缓冲池在内存中加快数据查询的效率，减少IO。当数据修改时，首先修改缓冲池中的页，然后数据库以一定的频率采用checkpoint机制将数据回写到磁盘中。

# 缓冲池大小

MyISAM：key_buffer_size

InnoDB：innodb_buffer_pool_size

# 加载页的方式

执行sql后，可以通过last_query_cost查看所需读取的页的数量

1. 内存加载。直接从内存加载，1ms很快
2. 磁盘加载。10ms，较慢
   - 排队：3ms
   - 寻道：4ms
   - 半圈旋转：2ms
   - 传输：1ms
3. 顺序读取。磁盘相邻存储的页都批量读取出来，减少IO

# 索引片和过滤因子

宽索引有助于减少回表次数，加快查询。

联合过滤因子更有效的过滤大量记录，加快查询	

# 三星索引

* where条件中的条件列作为索引片的开始。过滤更多记录
* order by 和 group by 的列加入索引。避免file sort，内存排序
* select 中剩余的字段加入索引。避免回表

不能完全采用三星索引。原因是三星索引导致宽索引，占用较多存储资源，缓冲区，减少加载页的数量。且索引列过多时，维护成本更高，修改时也会慢

# 锁

在MySQL中，InnoDB支持表锁和行锁。当为某一行数据加上S锁时，会先加上表级意向共享锁；加上X锁时，会先加上表级意向排他锁。意向锁的作用是表明已有事务锁定了表中的某些记录，不能加锁；避免了判断是否加上行锁进行遍历，提高效率。

当SELECT时，数据库会加上S锁（共享锁），在释放之前数据是只读模式，不可修改。

当INSERT|UPDATE|DELETE时，数据库会加上X锁（排他锁），在释放之前只能由加锁的事务进行操作，其他事务无法访问。

多个事务获取读S锁时，可能死锁。

# MVCC

- 解决读写阻塞问题。
- 降低死锁概率。乐观锁，读不加锁，写只加锁必要的行
- 解决一致性读问题。快照读，只读当前时间点之前事务提交的更新，不能读当前时间点之后事务提交的更新。

所谓快照读就是读取快照，不加锁的SELECT都是快照读。当前读则是读取最新数据，而不是历史版本，加锁的SELECT或UPDADTE|INSERT|DELETE数据都是当前读。

## 实现

1. read view

   保存了当前事务开启时所有未提交事务的列表，从另个角度来说，即保存了不该被看到的其他事务的列表。

   - trx_ids，事务id的集合
   - low_limit_id，最大的事务id
   - up_limit_id，最小的事务id
   - creator_trx_id，创建当前read view的事务id

   假设现在有事务 creator_trx_id 想要读取某个事务 ID 为 trx_id的行记录，有以下3中情况

   1. trx_id < up_limit_id，说明这个行记录在这些活跃的事务创建之前就已经提交了，所以此条记录对这条事务可见
   2. trx_id > low_limit_id，说明这个行记录在这些活跃的事务创建之后才创建，所以此条记录对这条事务不可见
   3. up_limit_id < trx_id < low_limit_id，说明该行记录所在的事务 trx_id 在目前 creator_trx_id 这个事务创建的时候，可能还处于活跃的状态，因此需要在 trx_ids 集合中进行遍历，如果 trx_id 存在于 trx_ids 集合中，证明这个事务 trx_id 还处于活跃状态，不可见。否则，如果 trx_id 不存在于 trx_ids 集合中，证明事务 trx_id 已经提交了，该行记录可见

2. 隐藏列

   - db_row_id，隐藏行id，聚簇索引，没有指定时使用该列加速查询
   - db_trx_id，最后一个更新或者插入此数据的事务id
   - db_roll_ptr，回滚指针，指向此记录的undo log的信息

3. undo log

   回滚指针将所有的快照版本通过链表的方式串联了起来

综上，一条sql执行的过程如下

1. 首先生成事务id
2. 创建read view
3. 查询得到的数据，与read view中的事务版本号比较
4. 如果符合规则，则可见，返回数据，
5. 否则查找undo log中的历史快照，返回数据

需要说明的是读已提交，每次查询都会生成read view，因此仍然可能不可重复读或欢度；可重复读只在第一次查询是生成read view，并在之后使用同一个read view，解决了不可重复读的问题。

